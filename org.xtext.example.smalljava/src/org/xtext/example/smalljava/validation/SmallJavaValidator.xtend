/*
 * generated by Xtext 2.13.0
 */
package org.xtext.example.smalljava.validation

import org.xtext.example.smalljava.SmallJavaModelUtil
import org.xtext.example.smalljava.smallJava.SJClass
import org.xtext.example.smalljava.smallJava.SmallJavaPackage
import com.google.inject.Inject
import org.eclipse.xtext.validation.Check
import org.xtext.example.smalljava.smallJava.SJMemberSelection
import org.xtext.example.smalljava.smallJava.SJField
import org.xtext.example.smalljava.smallJava.SJMethod
import org.xtext.example.smalljava.smallJava.SJExpression
import org.xtext.example.smalljava.typing.SmallJavaTypeConformance
import org.xtext.example.smalljava.typing.SmallJavaTypeComputer

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class SmallJavaValidator extends AbstractSmallJavaValidator {
	
	protected static val ISSUE_CODE_PREFIX = "org.example.smalljava."
	public static val GERARCHIA_CICLICA = ISSUE_CODE_PREFIX + "GerarchiaCiclica"
	
	@Inject extension SmallJavaModelUtil
	
	@Check def checkGerarchiaClassi(SJClass c){
		if(c.classHierarchy.contains(c)){
			error("ciclo nella gerarchia della classe '" + c.name +"'",
				SmallJavaPackage.eINSTANCE.SJClass_Superclass,
				GERARCHIA_CICLICA, c.superclass.name)
		}
	}
	
	public static val SELEZIONE_ATTRIBUTO_IN_CHIAMATA = ISSUE_CODE_PREFIX + "SelezioneAttributoInChiamata"
	public static val CHIAMATA_METODO_IN_ATTRIBUTO = ISSUE_CODE_PREFIX + "ChiamataMetodoInAttributo"
	@Check def void checkSelezioneAttributo(SJMemberSelection sel){
		val membro = sel.member
		if(membro instanceof SJField && sel.methodinvocation)
			error("Hai usato l'attributo '"+ membro.name + "' come se fosse un metodo!",
				SmallJavaPackage.eINSTANCE.SJMemberSelection_Methodinvocation,
				SELEZIONE_ATTRIBUTO_IN_CHIAMATA)
		else if(membro instanceof SJMethod && !sel.methodinvocation) 
			error("Hai usato il metodo '"+ membro.name + "' come se fosse un attributo!",
				SmallJavaPackage.eINSTANCE.SJMemberSelection_Methodinvocation,
				CHIAMATA_METODO_IN_ATTRIBUTO)
	}
	
	@Inject extension SmallJavaTypeComputer
	@Inject extension SmallJavaTypeConformance
	public static val TIPI_INCOMPATIBILI = ISSUE_CODE_PREFIX + "TipiIncompatibili"
	@Check def void checkConformance(SJExpression exp) {
		val actualType = exp.typeFor
		val expectedType = exp.expectedType
		if (expectedType === null || actualType === null)
			return; // nothing to check
		if (!actualType.isConformant(expectedType)) {
			error("Tipi incompatibili. Mi aspettavo un '" + expectedType.name 
				+ "' ma invece era '" + actualType.name + "'",
				null, TIPI_INCOMPATIBILI);
		}
	}
	
	public static val OVERRIDE_SBAGLIATO = ISSUE_CODE_PREFIX + "OverrideSbagliato"
	
	@Check def void checkMethodOverride(SJClass c) {
		val hierarchyMethods = c.classHierarchyMethods
		for (m : c.methods) {
			val overridden = hierarchyMethods.get(m.name)
			if (overridden !== null &&
				(!m.type.isConformant(overridden.type) ||
				!m.params.map[type].elementsEqual(overridden.params.map[type]))) {
				error("Il metodo '" + m.name + "'deve effettuare l'override in modo corretto!",
					m, SmallJavaPackage.eINSTANCE.SJNamedElement_Name,
					OVERRIDE_SBAGLIATO)
			} 
		}
	}
}
