/*
 * generated by Xtext 2.13.0
 */
package org.xtext.example.smalljava.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.smalljava.SmallJavaModelUtil
import org.xtext.example.smalljava.smallJava.SJClass
import org.xtext.example.smalljava.smallJava.SJProgram
import org.xtext.example.smalljava.smallJava.SJParameter
import org.xtext.example.smalljava.smallJava.SJBlock
import org.xtext.example.smalljava.smallJava.SJStatement
import org.xtext.example.smalljava.smallJava.SJVariableDeclaration
import org.xtext.example.smalljava.smallJava.SJReturn
import org.xtext.example.smalljava.smallJava.SJIfStatement
import org.xtext.example.smalljava.smallJava.SJNull
import org.xtext.example.smalljava.smallJava.SJThis
import org.xtext.example.smalljava.smallJava.SJSymbolRef
import org.xtext.example.smalljava.smallJava.SJNew
import org.xtext.example.smalljava.smallJava.SJAssignment
import org.xtext.example.smalljava.smallJava.SJMemberSelection
import com.google.inject.Inject
import org.eclipse.xtext.naming.IQualifiedNameProvider

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SmallJavaGenerator extends AbstractGenerator {

	
	@Inject extension SmallJavaModelUtil

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val program = resource.allContents.toIterable.filter(SJProgram).head
		// an empty program is a valid SmallJava program
		if (program === null)
			return;

		for (smallJavaClass : program.classes) {
			fsa.generateFile
				(smallJavaClass.fullyQualifiedName.toString.replace(".", "/") + ".java",
					
				'''
				package smalljava.example
				public class «smallJavaClass.name» «IF smallJavaClass.superclass !== null»
					extends «smallJavaClass.superclass.compileTypeReference» «ENDIF»{
					«FOR field : smallJavaClass.fields»
					public «field.type.compileTypeReference» «field.name»;
					«ENDFOR»
					«FOR method : smallJavaClass.methods»
					public «method.type.compileTypeReference» «method.name»
					(«method.params.map[compileParam].join(", ")») «compileBlock(method.body)»
					«ENDFOR»
				}
				'''
			)
		}
	}

	@Inject extension IQualifiedNameProvider
	def compileTypeReference(SJClass c) {
		c.fullyQualifiedName.toString
	}

	def compileParam(SJParameter p) {
		'''«p.type.compileTypeReference» «p.name»'''
	}

	def compileBlock(SJBlock block) '''
		{
			«FOR s : block.statements»
			«compileStatement(s)»
			«ENDFOR»
		}
	'''

	def String compileStatement(SJStatement s) {
		switch (s) {
			SJVariableDeclaration: '''«s.type.compileTypeReference» «s.name»
			 = «s.expression.compileExpression»;'''
			SJReturn: "return " + s.expression.compileExpression + ";"
			SJIfStatement: '''
			if («s.expression.compileExpression»)
				«s.thenBlock.compileBlock»
			«IF s.elseBlock !== null»
			else
				«s.elseBlock.compileBlock»
			«ENDIF»
			'''
			default: s.compileExpression + ";"
		}
	}

	def String compileExpression(SJStatement s) {
		switch (s) {
			SJNull: "null"
			SJThis: "this"
			SJSymbolRef: s.symbol.name
			SJNew: "new " + s.type.compileTypeReference + "()"
			SJAssignment: {
				s.left.compileExpression + " = " + s.right.compileExpression
			}
			SJMemberSelection: {
				s.receiver.compileExpression + "." + s.member.name +
				if (s.methodinvocation) {
					"(" + s.args.map[compileExpression].join(", ") + ")"
				} else {
					""
				}
			}
		}
	}
}
