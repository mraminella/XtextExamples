/**
 * generated by Xtext 2.13.0
 */
package org.xtext.example.smalljava.validation;

import com.google.inject.Inject;
import java.util.Map;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.xtext.example.smalljava.SmallJavaModelUtil;
import org.xtext.example.smalljava.smallJava.SJClass;
import org.xtext.example.smalljava.smallJava.SJExpression;
import org.xtext.example.smalljava.smallJava.SJField;
import org.xtext.example.smalljava.smallJava.SJMember;
import org.xtext.example.smalljava.smallJava.SJMemberSelection;
import org.xtext.example.smalljava.smallJava.SJMethod;
import org.xtext.example.smalljava.smallJava.SJParameter;
import org.xtext.example.smalljava.smallJava.SmallJavaPackage;
import org.xtext.example.smalljava.typing.SmallJavaTypeComputer;
import org.xtext.example.smalljava.typing.SmallJavaTypeConformance;
import org.xtext.example.smalljava.validation.AbstractSmallJavaValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class SmallJavaValidator extends AbstractSmallJavaValidator {
  protected final static String ISSUE_CODE_PREFIX = "org.example.smalljava.";
  
  public final static String GERARCHIA_CICLICA = (SmallJavaValidator.ISSUE_CODE_PREFIX + "GerarchiaCiclica");
  
  @Inject
  @Extension
  private SmallJavaModelUtil _smallJavaModelUtil;
  
  @Check
  public void checkGerarchiaClassi(final SJClass c) {
    boolean _contains = this._smallJavaModelUtil.classHierarchy(c).contains(c);
    if (_contains) {
      String _name = c.getName();
      String _plus = ("ciclo nella gerarchia della classe \'" + _name);
      String _plus_1 = (_plus + "\'");
      this.error(_plus_1, 
        SmallJavaPackage.eINSTANCE.getSJClass_Superclass(), 
        SmallJavaValidator.GERARCHIA_CICLICA, c.getSuperclass().getName());
    }
  }
  
  public final static String SELEZIONE_ATTRIBUTO_IN_CHIAMATA = (SmallJavaValidator.ISSUE_CODE_PREFIX + "SelezioneAttributoInChiamata");
  
  public final static String CHIAMATA_METODO_IN_ATTRIBUTO = (SmallJavaValidator.ISSUE_CODE_PREFIX + "ChiamataMetodoInAttributo");
  
  @Check
  public void checkSelezioneAttributo(final SJMemberSelection sel) {
    final SJMember membro = sel.getMember();
    if (((membro instanceof SJField) && sel.isMethodinvocation())) {
      String _name = membro.getName();
      String _plus = ("Hai usato l\'attributo \'" + _name);
      String _plus_1 = (_plus + "\' come se fosse un metodo!");
      this.error(_plus_1, 
        SmallJavaPackage.eINSTANCE.getSJMemberSelection_Methodinvocation(), 
        SmallJavaValidator.SELEZIONE_ATTRIBUTO_IN_CHIAMATA);
    } else {
      if (((membro instanceof SJMethod) && (!sel.isMethodinvocation()))) {
        String _name_1 = membro.getName();
        String _plus_2 = ("Hai usato il metodo \'" + _name_1);
        String _plus_3 = (_plus_2 + "\' come se fosse un attributo!");
        this.error(_plus_3, 
          SmallJavaPackage.eINSTANCE.getSJMemberSelection_Methodinvocation(), 
          SmallJavaValidator.CHIAMATA_METODO_IN_ATTRIBUTO);
      }
    }
  }
  
  @Inject
  @Extension
  private SmallJavaTypeComputer _smallJavaTypeComputer;
  
  @Inject
  @Extension
  private SmallJavaTypeConformance _smallJavaTypeConformance;
  
  public final static String TIPI_INCOMPATIBILI = (SmallJavaValidator.ISSUE_CODE_PREFIX + "TipiIncompatibili");
  
  @Check
  public void checkConformance(final SJExpression exp) {
    final SJClass actualType = this._smallJavaTypeComputer.typeFor(exp);
    final SJClass expectedType = this._smallJavaTypeComputer.expectedType(exp);
    if (((expectedType == null) || (actualType == null))) {
      return;
    }
    boolean _isConformant = this._smallJavaTypeConformance.isConformant(actualType, expectedType);
    boolean _not = (!_isConformant);
    if (_not) {
      String _name = expectedType.getName();
      String _plus = ("Tipi incompatibili. Mi aspettavo un \'" + _name);
      String _plus_1 = (_plus + "\' ma invece era \'");
      String _name_1 = actualType.getName();
      String _plus_2 = (_plus_1 + _name_1);
      String _plus_3 = (_plus_2 + "\'");
      this.error(_plus_3, 
        null, SmallJavaValidator.TIPI_INCOMPATIBILI);
    }
  }
  
  public final static String OVERRIDE_SBAGLIATO = (SmallJavaValidator.ISSUE_CODE_PREFIX + "OverrideSbagliato");
  
  @Check
  public void checkMethodOverride(final SJClass c) {
    final Map<String, SJMethod> hierarchyMethods = this._smallJavaModelUtil.classHierarchyMethods(c);
    Iterable<SJMethod> _methods = this._smallJavaModelUtil.methods(c);
    for (final SJMethod m : _methods) {
      {
        final SJMethod overridden = hierarchyMethods.get(m.getName());
        if (((overridden != null) && ((!this._smallJavaTypeConformance.isConformant(m.getType(), overridden.getType())) || 
          (!IterableExtensions.elementsEqual(ListExtensions.<SJParameter, SJClass>map(m.getParams(), ((Function1<SJParameter, SJClass>) (SJParameter it) -> {
            return it.getType();
          })), ListExtensions.<SJParameter, SJClass>map(overridden.getParams(), ((Function1<SJParameter, SJClass>) (SJParameter it) -> {
            return it.getType();
          }))))))) {
          String _name = m.getName();
          String _plus = ("Il metodo \'" + _name);
          String _plus_1 = (_plus + "\'deve effettuare l\'override in modo corretto!");
          this.error(_plus_1, m, SmallJavaPackage.eINSTANCE.getSJNamedElement_Name(), 
            SmallJavaValidator.OVERRIDE_SBAGLIATO);
        }
      }
    }
  }
}
